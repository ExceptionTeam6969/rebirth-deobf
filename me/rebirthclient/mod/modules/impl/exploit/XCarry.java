//Deobfuscated with https://github.com/SimplyProgrammer/Minecraft-Deobfuscator3000 using mappings "C:\Users\23204\Desktop\cn×îÇ¿·´±àÒëÆ÷\1.12 stable mappings"!

//Decompiled by Procyon!

package me.rebirthclient.mod.modules.impl.exploit;

import net.minecraft.client.gui.inventory.*;
import java.util.concurrent.atomic.*;
import me.rebirthclient.mod.modules.settings.*;
import org.lwjgl.input.*;
import net.minecraft.inventory.*;
import java.util.*;
import net.minecraftforge.fml.common.gameevent.*;
import me.rebirthclient.mod.gui.screen.*;
import me.rebirthclient.mod.modules.*;
import java.util.function.*;
import java.util.concurrent.*;
import net.minecraftforge.client.event.*;
import net.minecraft.client.gui.*;
import net.minecraftforge.fml.common.eventhandler.*;
import net.minecraft.network.play.client.*;
import net.minecraft.network.*;
import me.rebirthclient.api.util.*;
import me.rebirthclient.api.events.impl.*;
import java.io.*;
import net.minecraft.entity.player.*;

public class XCarry extends Module
{
    private final Setting autoDuel;
    private final Setting tasks;
    public static XCarry INSTANCE;
    private GuiInventory openedGui;
    private boolean slot3done;
    private boolean slot1done;
    private final Setting simpleMode;
    private boolean guiCloseGuard;
    private final Setting slot1;
    private final Setting slot2;
    private List doneSlots;
    private boolean slot2done;
    private final Setting withShift;
    private final Setting slot3;
    private final AtomicBoolean shouldCloseGui;
    private final Setting keyBind;
    private boolean obbySlotDone;
    private final Setting obbySlot;
    private final Setting shiftClicker;
    private boolean autoDuelOn;
    private final Queue queuedTaskList;
    
    private void closeGui() {
        if (this.shouldCloseGui.compareAndSet(true, false) && !fullNullCheck()) {
            this.guiCloseGuard = true;
            if (XCarry.mc.currentScreen != null) {
                XCarry.mc.player.closeScreen();
            }
            if (this.openedGui != null) {
                this.openedGui.onGuiClosed();
                this.openedGui = null;
            }
            this.guiCloseGuard = false;
        }
    }
    
    @Override
    public void onLogout() {
        this.onDisable();
    }
    
    private void addTasks(final int n) {
        if (InventoryUtil.getEmptyXCarry() != -1) {
            int emptyXCarry = InventoryUtil.getEmptyXCarry();
            if ((this.doneSlots.contains(emptyXCarry) || !InventoryUtil.isSlotEmpty(emptyXCarry)) && (this.doneSlots.contains(++emptyXCarry) || !InventoryUtil.isSlotEmpty(emptyXCarry)) && (this.doneSlots.contains(++emptyXCarry) || !InventoryUtil.isSlotEmpty(emptyXCarry)) && (this.doneSlots.contains(++emptyXCarry) || !InventoryUtil.isSlotEmpty(emptyXCarry))) {
                return;
            }
            if (emptyXCarry > 4) {
                return;
            }
            this.doneSlots.add(emptyXCarry);
            this.queuedTaskList.add(new InventoryUtil.QueuedTask(n));
            this.queuedTaskList.add(new InventoryUtil.QueuedTask(emptyXCarry));
            this.queuedTaskList.add(new InventoryUtil.QueuedTask());
        }
    }
    
    private boolean lambda$new$2(final Integer n) {
        return ((Bind)this.autoDuel.getValue()).getKey() != -1;
    }
    
    static {
        XCarry.INSTANCE = new XCarry();
    }
    
    @Override
    public void onUpdate() {
        if ((boolean)this.shiftClicker.getValue() && XCarry.mc.currentScreen instanceof GuiInventory) {
            final boolean b = ((Bind)this.keyBind.getValue()).getKey() != -1 && Keyboard.isKeyDown(((Bind)this.keyBind.getValue()).getKey()) && !Keyboard.isKeyDown(42);
            final Slot slotUnderMouse;
            if (((Keyboard.isKeyDown(42) && (boolean)this.withShift.getValue()) || b) && Mouse.isButtonDown(0) && (slotUnderMouse = ((GuiInventory)XCarry.mc.currentScreen).getSlotUnderMouse()) != null && InventoryUtil.getEmptyXCarry() != -1) {
                final int slotNumber = slotUnderMouse.slotNumber;
                if (slotNumber > 4 && b) {
                    this.queuedTaskList.add(new InventoryUtil.QueuedTask(slotNumber));
                    this.queuedTaskList.add(new InventoryUtil.QueuedTask(InventoryUtil.getEmptyXCarry()));
                }
                else if (slotNumber > 4 && (boolean)this.withShift.getValue()) {
                    final boolean b2 = true;
                    final boolean b3 = true;
                    for (final int intValue : InventoryUtil.findEmptySlots(false)) {
                        if (intValue > 4 && intValue < 36) {
                            return;
                        }
                        if (intValue <= 35) {
                            continue;
                        }
                        if (intValue >= 45) {
                            return;
                        }
                        return;
                    }
                    if (slotNumber > 35 && slotNumber < 45) {
                        if (b3) {
                            this.queuedTaskList.add(new InventoryUtil.QueuedTask(slotNumber));
                            this.queuedTaskList.add(new InventoryUtil.QueuedTask(InventoryUtil.getEmptyXCarry()));
                        }
                    }
                    else if (b2) {
                        this.queuedTaskList.add(new InventoryUtil.QueuedTask(slotNumber));
                        this.queuedTaskList.add(new InventoryUtil.QueuedTask(InventoryUtil.getEmptyXCarry()));
                    }
                }
            }
        }
        if (this.autoDuelOn) {
            this.doneSlots = new ArrayList();
            if (InventoryUtil.getEmptyXCarry() == -1 || (this.obbySlotDone && this.slot1done && this.slot2done && this.slot3done)) {
                this.autoDuelOn = false;
            }
            if (this.autoDuelOn) {
                if (!this.obbySlotDone && !XCarry.mc.player.inventory.getStackInSlot((int)this.obbySlot.getValue() - 1).isEmpty) {
                    this.addTasks(36 + (int)this.obbySlot.getValue() - 1);
                }
                this.obbySlotDone = true;
                if (!this.slot1done && !XCarry.mc.player.inventoryContainer.inventorySlots.get((int)this.slot1.getValue()).getStack().isEmpty) {
                    this.addTasks((int)this.slot1.getValue());
                }
                this.slot1done = true;
                if (!this.slot2done && !XCarry.mc.player.inventoryContainer.inventorySlots.get((int)this.slot2.getValue()).getStack().isEmpty) {
                    this.addTasks((int)this.slot2.getValue());
                }
                this.slot2done = true;
                if (!this.slot3done && !XCarry.mc.player.inventoryContainer.inventorySlots.get((int)this.slot3.getValue()).getStack().isEmpty) {
                    this.addTasks((int)this.slot3.getValue());
                }
                this.slot3done = true;
            }
        }
        else {
            this.obbySlotDone = false;
            this.slot1done = false;
            this.slot2done = false;
            this.slot3done = false;
        }
        if (!this.queuedTaskList.isEmpty()) {
            int n = 0;
            if (n < (int)this.tasks.getValue()) {
                final InventoryUtil.QueuedTask queuedTask = this.queuedTaskList.poll();
                if (queuedTask != null) {
                    queuedTask.run();
                }
                ++n;
            }
        }
    }
    
    private boolean lambda$new$1(final Integer n) {
        return ((Bind)this.autoDuel.getValue()).getKey() != -1;
    }
    
    private void close() {
        this.openedGui = null;
        this.shouldCloseGui.set(false);
        this.guiCloseGuard = false;
    }
    
    private boolean lambda$new$3(final Integer n) {
        return ((Bind)this.autoDuel.getValue()).getKey() != -1;
    }
    
    @SubscribeEvent
    public void onKeyInput(final InputEvent.KeyInputEvent keyInputEvent) {
        if (fullNullCheck()) {
            return;
        }
        if (Keyboard.getEventKeyState() && !(XCarry.mc.currentScreen instanceof Gui) && ((Bind)this.autoDuel.getValue()).getKey() == Keyboard.getEventKey()) {
            this.autoDuelOn = !this.autoDuelOn;
            this.sendMessage("<XCarry> ¡ìaAutostoring...");
        }
    }
    
    public XCarry() {
        super("XCarry", "Uses the crafting inventory for storage", Category.EXPLOIT);
        this.simpleMode = this.add(new Setting("Simple", false));
        this.autoDuel = this.add(new Setting("AutoDuel", new Bind(-1)));
        this.obbySlot = this.add(new Setting("ObbySlot", 2, 1, 9, this::lambda$new$0));
        this.slot1 = this.add(new Setting("Slot1", 22, 9, 44, this::lambda$new$1));
        this.slot2 = this.add(new Setting("Slot2", 23, 9, 44, this::lambda$new$2));
        this.slot3 = this.add(new Setting("Slot3", 24, 9, 44, this::lambda$new$3));
        this.tasks = this.add(new Setting("Actions", 3, 1, 12, this::lambda$new$4));
        this.shiftClicker = this.add(new Setting("ShiftClick", false).setParent());
        this.withShift = this.add(new Setting("WithShift", true, this::lambda$new$5));
        this.keyBind = this.add(new Setting("ShiftBind", new Bind(-1), this::lambda$new$6));
        this.shouldCloseGui = new AtomicBoolean(false);
        this.queuedTaskList = new ConcurrentLinkedQueue();
        this.doneSlots = new ArrayList();
        XCarry.INSTANCE = this;
    }
    
    @SubscribeEvent(priority = EventPriority.LOWEST)
    public void onGuiOpen(final GuiOpenEvent guiOpenEvent) {
        if (fullNullCheck()) {
            return;
        }
        if (!(boolean)this.simpleMode.getValue()) {
            if (this.guiCloseGuard) {
                guiOpenEvent.setCanceled(true);
            }
            else if (guiOpenEvent.getGui() instanceof GuiInventory) {
                guiOpenEvent.setGui((GuiScreen)(this.openedGui = this.createGuiWrapper((GuiInventory)guiOpenEvent.getGui())));
                this.shouldCloseGui.set(false);
            }
        }
    }
    
    private boolean lambda$new$5(final Boolean b) {
        return this.shiftClicker.isOpen();
    }
    
    static AtomicBoolean access$000(final XCarry xCarry) {
        return xCarry.shouldCloseGui;
    }
    
    private boolean lambda$new$4(final Integer n) {
        return ((Bind)this.autoDuel.getValue()).getKey() != -1;
    }
    
    @SubscribeEvent
    public void onSettingChange(final ClientEvent clientEvent) {
        if (fullNullCheck()) {
            return;
        }
        if (clientEvent.getStage() == 2 && clientEvent.getSetting() != null && clientEvent.getSetting().getMod() != null && clientEvent.getSetting().getMod().equals(this)) {
            final Setting setting = clientEvent.getSetting();
            final String name = clientEvent.getSetting().getName();
            if (setting.equals(this.simpleMode) && setting.getPlannedValue() != setting.getValue()) {
                this.disable();
            }
            else if (Integer.valueOf("Store".toUpperCase().hashCode()).equals(name.toUpperCase().hashCode())) {
                clientEvent.setCanceled(true);
                this.autoDuelOn = !this.autoDuelOn;
                this.sendMessage("<XCarry> ¡ìaAutostoring...");
            }
        }
    }
    
    static boolean access$100(final XCarry xCarry) {
        return xCarry.guiCloseGuard;
    }
    
    @Override
    public void onDisable() {
        if (!fullNullCheck()) {
            if (!(boolean)this.simpleMode.getValue()) {
                this.closeGui();
                this.close();
            }
            else {
                XCarry.mc.player.connection.sendPacket((Packet)new CPacketCloseWindow(XCarry.mc.player.inventoryContainer.windowId));
            }
        }
    }
    
    private GuiInventory createGuiWrapper(final GuiInventory guiInventory) {
        try {
            final GuiInventoryWrapper guiInventoryWrapper = new GuiInventoryWrapper();
            ReflectionUtil.copyOf((Object)guiInventory, (Object)guiInventoryWrapper);
            return guiInventoryWrapper;
        }
        catch (IllegalAccessException | NoSuchFieldException ex) {
            final Throwable t;
            t.printStackTrace();
            return null;
        }
    }
    
    private boolean lambda$new$6(final Bind bind) {
        return this.shiftClicker.isOpen();
    }
    
    private boolean lambda$new$0(final Integer n) {
        return ((Bind)this.autoDuel.getValue()).getKey() != -1;
    }
    
    @SubscribeEvent
    public void onGuiClose(final PacketEvent.Send send) {
        if (fullNullCheck()) {
            return;
        }
        if ((boolean)this.simpleMode.getValue() && send.getPacket() instanceof CPacketCloseWindow && ((CPacketCloseWindow)send.getPacket()).windowId == XCarry.mc.player.inventoryContainer.windowId) {
            send.setCanceled(true);
        }
    }
    
    private class GuiInventoryWrapper extends GuiInventory
    {
        final XCarry this$0;
        
        protected void keyTyped(final char c, final int n) throws IOException {
            if (this.this$0.isOn() && (n == 1 || this.mc.gameSettings.keyBindInventory.isActiveAndMatches(n))) {
                XCarry.access$000(this.this$0).set(true);
                this.mc.displayGuiScreen((GuiScreen)null);
            }
            else {
                super.keyTyped(c, n);
            }
        }
        
        public void onGuiClosed() {
            if (XCarry.access$100(this.this$0) || !this.this$0.isOn()) {
                super.onGuiClosed();
            }
        }
        
        GuiInventoryWrapper(final XCarry this$0) {
            this.this$0 = this$0;
            super((EntityPlayer)XCarry.mc.player);
        }
    }
}
