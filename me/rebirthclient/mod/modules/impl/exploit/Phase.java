//Deobfuscated with https://github.com/SimplyProgrammer/Minecraft-Deobfuscator3000 using mappings "C:\Users\23204\Desktop\cn×îÇ¿·´±àÒëÆ÷\1.12 stable mappings"!

//Decompiled by Procyon!

package me.rebirthclient.mod.modules.impl.exploit;

import me.rebirthclient.mod.modules.settings.*;
import net.minecraft.world.*;
import net.minecraft.client.multiplayer.*;
import net.minecraft.block.*;
import net.minecraft.block.state.*;
import net.minecraft.init.*;
import me.rebirthclient.mod.modules.*;
import java.util.function.*;
import net.minecraft.entity.*;
import net.minecraft.util.math.*;
import me.rebirthclient.api.managers.impl.*;
import me.rebirthclient.api.util.*;
import net.minecraft.network.play.client.*;
import net.minecraft.network.*;

public class Phase extends Module
{
    private final Setting delay;
    private int tickTimer;
    private final Setting onBurrow;
    private final Setting mode;
    private final Setting offset2;
    private final Setting toggle;
    private final Setting offset;
    public static Phase INSTANCE;
    private final Setting onlyBurrow;
    
    public static boolean collideBlockIntersects(final AxisAlignedBB axisAlignedBB, final Function1 function1) {
        final WorldClient world = Phase.mc.world;
        int n = (int)Math.floor(Phase.mc.player.getEntityBoundingBox().minX);
        if (n >= (int)Math.floor(Phase.mc.player.getEntityBoundingBox().maxX) + 1) {
            return false;
        }
        final int n2 = n;
        ++n;
        int n3 = (int)Math.floor(Phase.mc.player.getEntityBoundingBox().minZ);
        if (n3 < (int)Math.floor(Phase.mc.player.getEntityBoundingBox().maxZ) + 1) {
            final int n4 = n3;
            ++n3;
            final BlockPos blockPos = new BlockPos((double)n2, axisAlignedBB.minY, (double)n4);
            final WorldClient world2 = Phase.mc.world;
            Block getBlock;
            if (world2 == null) {
                getBlock = null;
            }
            else {
                getBlock = world2.getBlockState(blockPos).getBlock();
            }
            final Block block = getBlock;
            if (function1.invoke(block)) {
                final WorldClient world3 = Phase.mc.world;
                final IBlockState blockState = (world3 == null) ? null : world3.getBlockState(blockPos);
                AxisAlignedBB axisAlignedBB2;
                if (blockState == null) {
                    axisAlignedBB2 = null;
                }
                else {
                    axisAlignedBB2 = ((block == null) ? null : block.getSelectedBoundingBox(blockState, (World)world, blockPos));
                }
                final AxisAlignedBB axisAlignedBB3 = axisAlignedBB2;
                if (axisAlignedBB3 == null) {
                    return false;
                }
                if (Phase.mc.player.getEntityBoundingBox().intersects(axisAlignedBB3)) {
                    return true;
                }
            }
            return false;
        }
        return false;
    }
    
    public static double getDirection() {
        float rotationYaw = Phase.mc.player.rotationYaw;
        if (Phase.mc.player.moveVertical < 0.0f) {
            rotationYaw += 180.0f;
        }
        float n = 1.0f;
        if (Phase.mc.player.moveVertical < 0.0f) {
            n = -0.5f;
        }
        else if (Phase.mc.player.moveVertical > 0.0f) {
            n = 0.5f;
        }
        if (Phase.mc.player.moveStrafing > 0.0f) {
            rotationYaw -= 90.0f * n;
        }
        if (Phase.mc.player.moveStrafing < 0.0f) {
            rotationYaw += 90.0f * n;
        }
        return Math.toRadians(rotationYaw);
    }
    
    private boolean lambda$new$0(final Boolean b) {
        return this.mode.getValue() == Mode.Skip;
    }
    
    private static Boolean lambda$onTick$6(final Block block) {
        return block != Blocks.AIR;
    }
    
    private boolean lambda$new$3(final Integer n) {
        return this.mode.getValue() == Mode.Skip;
    }
    
    public Phase() {
        super("Phase", "esu dog", Category.EXPLOIT);
        this.mode = this.add(new Setting("Mode", Mode.Stuck));
        this.onlyBurrow = this.add(new Setting("OnlyBurrow", true, this::lambda$new$0));
        this.onBurrow = this.add(new Setting("OnBurrow", false, this::lambda$new$1));
        this.offset2 = this.add(new Setting("Speed", 0.6, 0.1, 1.0, this::lambda$new$2));
        this.delay = this.add(new Setting("Delay", 1, 0, 20, this::lambda$new$3));
        this.offset = this.add(new Setting("Offset", 1, 0, 10, this::lambda$new$4));
        this.toggle = this.add(new Setting("AutoToggle", false, this::lambda$new$5));
        Phase.INSTANCE = this;
    }
    
    static {
        Phase.INSTANCE = new Phase();
    }
    
    private boolean lambda$new$5(final Boolean b) {
        return this.mode.getValue() == Mode.Stuck;
    }
    
    @Override
    public void onTick() {
        if (this.mode.getValue() == Mode.Stuck) {
            final double n = Math.abs(Phase.mc.player.posX) - Math.floor(Math.abs(Phase.mc.player.posX));
            final double n2 = Math.abs(Phase.mc.player.posZ) - Math.floor(Math.abs(Phase.mc.player.posZ));
            if (n == 0.7 || n == 0.3 || n2 == 0.7 || n2 == 0.3 || (!(boolean)this.onBurrow.getValue() && !Phase.mc.world.getBlockState(BlockUtil.getFlooredPosition((Entity)Phase.mc.player)).getBlock().equals(Blocks.AIR))) {
                return;
            }
            final Vec3d getPositionVector = Phase.mc.player.getPositionVector();
            if (!Phase.mc.world.getBlockState(BlockUtil.vec3toBlockPos(getPositionVector.add(new Vec3d(0.3 + (int)this.offset.getValue() / 100.0, 0.2, 0.0)))).getBlock().equals(Blocks.AIR)) {
                Phase.mc.player.setPosition(Phase.mc.player.posX + (int)this.offset.getValue() / 100.0, Phase.mc.player.posY, Phase.mc.player.posZ);
                if (this.toggle.getValue()) {
                    this.disable();
                }
                return;
            }
            if (!Phase.mc.world.getBlockState(BlockUtil.vec3toBlockPos(getPositionVector.add(new Vec3d(-0.3 - (int)this.offset.getValue() / 100.0, 0.2, 0.0)))).getBlock().equals(Blocks.AIR)) {
                Phase.mc.player.setPosition(Phase.mc.player.posX - (int)this.offset.getValue() / 100.0, Phase.mc.player.posY, Phase.mc.player.posZ);
                if (this.toggle.getValue()) {
                    this.disable();
                }
                return;
            }
            if (!Phase.mc.world.getBlockState(BlockUtil.vec3toBlockPos(getPositionVector.add(new Vec3d(0.0, 0.2, 0.3 + (int)this.offset.getValue() / 100.0)))).getBlock().equals(Blocks.AIR)) {
                Phase.mc.player.setPosition(Phase.mc.player.posX, Phase.mc.player.posY, Phase.mc.player.posZ + (int)this.offset.getValue() / 100.0);
                if (this.toggle.getValue()) {
                    this.disable();
                }
                return;
            }
            if (!Phase.mc.world.getBlockState(BlockUtil.vec3toBlockPos(getPositionVector.add(new Vec3d(0.0, 0.2, -0.3 - (int)this.offset.getValue() / 100.0)))).getBlock().equals(Blocks.AIR)) {
                Phase.mc.player.setPosition(Phase.mc.player.posX, Phase.mc.player.posY, Phase.mc.player.posZ - (int)this.offset.getValue() / 100.0);
                if (this.toggle.getValue()) {
                    this.disable();
                }
            }
        }
        else {
            ++this.tickTimer;
            final boolean collideBlockIntersects = collideBlockIntersects(Phase.mc.player.getEntityBoundingBox(), Phase::lambda$onTick$6);
            if (!Phase.mc.player.onGround || this.tickTimer < (int)this.delay.getValue() || !Phase.mc.player.collidedHorizontally) {
                return;
            }
            if (collideBlockIntersects && !SneakManager.isSneaking && !(boolean)this.onBurrow.getValue() && !(boolean)this.onlyBurrow.getValue()) {
                return;
            }
            if ((boolean)this.onlyBurrow.getValue() && !collideBlockIntersects && Phase.mc.world.isAirBlock(EntityUtil.getPlayerPos().up()) && Phase.mc.world.getBlockState(EntityUtil.getPlayerPos()).getBlock() != Blocks.PISTON_HEAD) {
                return;
            }
            final double direction = getDirection();
            final double n3 = -Math.sin(direction) * (double)this.offset2.getValue();
            final double n4 = Math.cos(direction) * (double)this.offset2.getValue();
            int n5 = 0;
            if (n5 < 3) {
                Phase.mc.player.connection.sendPacket((Packet)new CPacketPlayer.Position(Phase.mc.player.posX, Phase.mc.player.posY + 0.06, Phase.mc.player.posZ, true));
                Phase.mc.player.connection.sendPacket((Packet)new CPacketPlayer.Position(Phase.mc.player.posX + n3 * n5, Phase.mc.player.posY, Phase.mc.player.posZ + n4 * n5, true));
                ++n5;
                return;
            }
            Phase.mc.player.setEntityBoundingBox(Phase.mc.player.getEntityBoundingBox().offset(n3, 0.0, n4));
            Phase.mc.player.setPositionAndUpdate(Phase.mc.player.posX + n3, Phase.mc.player.posY, Phase.mc.player.posZ + n4);
            this.tickTimer = 0;
        }
    }
    
    private boolean lambda$new$4(final Integer n) {
        return this.mode.getValue() == Mode.Stuck;
    }
    
    private boolean lambda$new$1(final Boolean b) {
        return !(boolean)this.onlyBurrow.getValue() || this.mode.getValue() == Mode.Stuck;
    }
    
    private boolean lambda$new$2(final Double n) {
        return this.mode.getValue() == Mode.Skip;
    }
    
    public interface Function
    {
    }
    
    public enum Mode
    {
        Stuck("Stuck", 0);
        
        private static final Mode[] $VALUES;
        
        Skip("Skip", 1);
        
        static {
            $VALUES = new Mode[] { Mode.Stuck, Mode.Skip };
        }
        
        private Mode(final String s, final int n) {
        }
    }
    
    public interface Function1 extends Function
    {
        Object invoke(final Object p0);
    }
}
